{"version":3,"sources":["lib/operators.js","node_modules/deep-equal/lib/keys.js","node_modules/deep-equal/lib/is_arguments.js","node_modules/deep-equal/index.js","lib/helpers.js","lib/Collection.js","index.js"],"names":["isDevelopmentEnv","$avg","cache","target","record","currentValue","groupId","cacheId","JSON","stringify","value","Number","isInteger","n","newValue","$first","$last","$max","generateMinMax","$min","$sum","SyntaxError","$push","arr","length","TypeError","reduce","newRecord","field","push","$addToSet","indexOf","op","operators","resolveOperator","options","operatorObj","operatorObjKeys","Object","keys","operator","module","exports","deepEqual","require","getGroupId","id","obj","candidateId","Array","isArray","aggregated","key","getGroup","idx","groupObj","findIndex","item","splice","getGroupKeys","exists","Collection","json","data","parse","e","filter","fields","matches","doc","unwinded","forEach","arrField","assign","Error","criteria","compareFn","sortValue","Math","abs","sort","compare","a","b","i","order","slice"],"mappings":"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","file":"json-aggregate.map","sourceRoot":"..","sourcesContent":["const isDevelopmentEnv = process.env.NODE_ENV !== 'production'\n\nconst $avg = (function () {\n  const cache = {}\n  return function (target, record, currentValue, groupId) {\n    const cacheId = JSON.stringify(groupId)\n    if (typeof target !== 'string') {\n      return currentValue\n    }\n    const value = record[target]\n    if (!Number.isInteger(value)) {\n      return currentValue\n    }\n    if (!cache[cacheId]) {\n      cache[cacheId] = [1, value]\n      return value\n    }\n    const [n, avg] = cache[cacheId]\n    const newValue = ((n * avg) + value) / (n + 1)\n    cache[cacheId] = [n + 1, newValue]\n    return newValue\n  }\n}())\n\nfunction $first (target, record, currentValue) {\n  if (currentValue) return currentValue\n  const value = record[target]\n  if (typeof value === 'undefined') {\n    return currentValue\n  }\n  return value\n}\n\nconst $last = (target, record) => record[target]\n\nconst $max = generateMinMax('max')\n\nconst $min = generateMinMax('min')\n\nfunction $sum (target, record, currentValue) {\n  currentValue = Number.isInteger(currentValue) ? currentValue : 0\n  if (target === 1) {\n    return currentValue + 1\n  } else if (typeof target === 'string') {\n    const value = record[target]\n    if (typeof value !== 'number') {\n      return currentValue\n    } else {\n      return currentValue + value\n    }\n  } else {\n    if (isDevelopmentEnv) throw new SyntaxError('Invalid target.')\n  }\n}\n\nfunction $push (arr, record, currentValue) {\n  if (!arr.length && isDevelopmentEnv) {\n    throw new TypeError('$push expects an array of fields (string).')\n  }\n  const value = arr.reduce((newRecord, field) => {\n    newRecord[field] = record[field]\n    return newRecord\n  }, {})\n  if (currentValue) {\n    currentValue.push(value)\n    return currentValue\n  }\n  return [value]\n}\n\nfunction $addToSet (target, record, currentValue) {\n  if (typeof target !== 'string' && isDevelopmentEnv) {\n    throw TypeError('$addToSet expects a field (string).')\n  }\n  const value = record[target]\n  if (currentValue) {\n    if (currentValue.indexOf(value) === -1) {\n      currentValue.push(value)\n    }\n    return currentValue\n  }\n  return [value]\n}\n\n/*\n * TODO\n * function $ranges () {} // $bucket\n*/\n\n// min-max helper\nfunction generateMinMax (op) {\n  return function (target, record, currentValue) {\n    if (typeof target !== 'string') {\n      return currentValue\n    }\n    const value = record[target]\n    if (!Number.isInteger(value)) {\n      return currentValue\n    }\n    const condition = op === 'min' ? currentValue < value : currentValue > value\n    return condition ? currentValue : value\n  }\n}\n\nconst operators = {\n  $avg,\n  $first,\n  $last,\n  $max,\n  $min,\n  $sum,\n  $push,\n  $addToSet\n}\n\nfunction resolveOperator (options) {\n  const { operatorObj, record, currentValue, groupId } = options\n  if (typeof operatorObj !== 'object' && isDevelopmentEnv) {\n    throw TypeError('Expected a value/key pair.')\n  }\n  const operatorObjKeys = Object.keys(operatorObj)\n  if (operatorObjKeys.length > 1 && isDevelopmentEnv) {\n    throw SyntaxError('Only 1 operator per field is supported.')\n  }\n  const operator = operatorObjKeys[0]\n  const target = operatorObj[operator]\n  if (Object.keys(operators).indexOf(operator) === -1 && isDevelopmentEnv) {\n    throw SyntaxError('Invalid operator.')\n  }\n\n  return operators[operator](target, record, currentValue, groupId)\n}\n\nmodule.exports = resolveOperator\n","exports = module.exports = typeof Object.keys === 'function'\n  ? Object.keys : shim;\n\nexports.shim = shim;\nfunction shim (obj) {\n  var keys = [];\n  for (var key in obj) keys.push(key);\n  return keys;\n}\n","var supportsArgumentsClass = (function(){\n  return Object.prototype.toString.call(arguments)\n})() == '[object Arguments]';\n\nexports = module.exports = supportsArgumentsClass ? supported : unsupported;\n\nexports.supported = supported;\nfunction supported(object) {\n  return Object.prototype.toString.call(object) == '[object Arguments]';\n};\n\nexports.unsupported = unsupported;\nfunction unsupported(object){\n  return object &&\n    typeof object == 'object' &&\n    typeof object.length == 'number' &&\n    Object.prototype.hasOwnProperty.call(object, 'callee') &&\n    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||\n    false;\n};\n","var pSlice = Array.prototype.slice;\nvar objectKeys = require('./lib/keys.js');\nvar isArguments = require('./lib/is_arguments.js');\n\nvar deepEqual = module.exports = function (actual, expected, opts) {\n  if (!opts) opts = {};\n  // 7.1. All identical values are equivalent, as determined by ===.\n  if (actual === expected) {\n    return true;\n\n  } else if (actual instanceof Date && expected instanceof Date) {\n    return actual.getTime() === expected.getTime();\n\n  // 7.3. Other pairs that do not both pass typeof value == 'object',\n  // equivalence is determined by ==.\n  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {\n    return opts.strict ? actual === expected : actual == expected;\n\n  // 7.4. For all other Object pairs, including Array objects, equivalence is\n  // determined by having the same number of owned properties (as verified\n  // with Object.prototype.hasOwnProperty.call), the same set of keys\n  // (although not necessarily the same order), equivalent values for every\n  // corresponding key, and an identical 'prototype' property. Note: this\n  // accounts for both named and indexed properties on Arrays.\n  } else {\n    return objEquiv(actual, expected, opts);\n  }\n}\n\nfunction isUndefinedOrNull(value) {\n  return value === null || value === undefined;\n}\n\nfunction isBuffer (x) {\n  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;\n  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {\n    return false;\n  }\n  if (x.length > 0 && typeof x[0] !== 'number') return false;\n  return true;\n}\n\nfunction objEquiv(a, b, opts) {\n  var i, key;\n  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))\n    return false;\n  // an identical 'prototype' property.\n  if (a.prototype !== b.prototype) return false;\n  //~~~I've managed to break Object.keys through screwy arguments passing.\n  //   Converting to array solves the problem.\n  if (isArguments(a)) {\n    if (!isArguments(b)) {\n      return false;\n    }\n    a = pSlice.call(a);\n    b = pSlice.call(b);\n    return deepEqual(a, b, opts);\n  }\n  if (isBuffer(a)) {\n    if (!isBuffer(b)) {\n      return false;\n    }\n    if (a.length !== b.length) return false;\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n  try {\n    var ka = objectKeys(a),\n        kb = objectKeys(b);\n  } catch (e) {//happens when one is a string literal and the other isn't\n    return false;\n  }\n  // having the same number of owned properties (keys incorporates\n  // hasOwnProperty)\n  if (ka.length != kb.length)\n    return false;\n  //the same set of keys (although not necessarily the same order),\n  ka.sort();\n  kb.sort();\n  //~~~cheap key test\n  for (i = ka.length - 1; i >= 0; i--) {\n    if (ka[i] != kb[i])\n      return false;\n  }\n  //equivalent values for every corresponding key, and\n  //~~~possibly expensive deep test\n  for (i = ka.length - 1; i >= 0; i--) {\n    key = ka[i];\n    if (!deepEqual(a[key], b[key], opts)) return false;\n  }\n  return typeof a === typeof b;\n}\n","const deepEqual = require('deep-equal')\n\nfunction getGroupId (id, obj) {\n  if (typeof id === 'string') {\n    const candidateId = obj[id]\n    if (!(typeof candidateId === 'string' ||\n        typeof candidateId === 'number')) {\n      throw TypeError('Only types \"string\" and \"number\" are supported for group ids.')\n    }\n    return candidateId\n  } else if (Array.isArray(id)) {\n    return id.reduce((aggregated, key) => {\n      aggregated[key] = obj[key]\n      return aggregated\n    }, {})\n  }\n}\n\nfunction getGroup (groupId, aggregated) {\n  let idx\n  if (Object.keys(groupId).length) {\n    idx = aggregated.findIndex(item => {\n      for (const field of Object.keys(item.id)) {\n        if (groupId[field] !== item.id[field]) {\n          return false\n        }\n      }\n      return true\n    })\n  } else if (typeof groupId === 'string') {\n    idx = aggregated.findIndex(item => item.id === groupId)\n  }\n  const groupObj = idx === -1 ? { id: groupId } : aggregated.splice(idx, 1)[0]\n  return groupObj\n}\n\nfunction getGroupKeys (groupId, aggregated) {\n  if (typeof groupId === 'string') {\n    if (aggregated.indexOf(groupId) === -1) {\n      aggregated.push(groupId)\n    }\n  } else if (typeof groupId === 'object') {\n    let exists = false\n    for (const record of aggregated) {\n      if (deepEqual(groupId, record.id)) {\n        exists = true\n        break\n      }\n    }\n    if (!aggregated.length || !exists) {\n      aggregated.push({ id: groupId })\n    }\n  }\n  return aggregated\n}\n\nmodule.exports = {\n  getGroupId,\n  getGroup,\n  getGroupKeys\n}\n","const resolveOperator = require('./operators')\nconst { getGroupId, getGroup, getGroupKeys } = require('./helpers')\n\nconst isDevelopmentEnv = process.env.NODE_ENV !== 'production'\n\nclass Collection {\n  constructor (json) {\n    try {\n      this.data = this.cache = JSON.parse(json)\n    } catch (e) {\n      if (isDevelopmentEnv) {\n        throw TypeError('Could not parse JSON.')\n      }\n      this.data = this.cache = [{}]\n    }\n    if (!this.data.length) {\n      this.data = [this.data]\n    }\n  }\n\n  match (options) {\n    if (typeof options === 'function') {\n      this.data = this.data.filter(options)\n    } else if (typeof options === 'object') {\n      const fields = Object.keys(options)\n      this.data = this.data.reduce((matches, doc) => {\n        for (const field of fields) {\n          if (doc[field] !== options[field]) return matches\n        }\n        matches.push(doc)\n        return matches\n      }, [])\n    } else {\n      if (isDevelopmentEnv) {\n        throw TypeError('match :: expects an object or a condition function.')\n      }\n    }\n    return this\n  }\n\n  unwind (field) {\n    const unwinded = []\n    this.data.forEach(record => {\n      const arrField = record[field]\n      if (!arrField || !arrField.length) {\n        unwinded.push(record)\n        return\n      }\n      arrField.forEach(value => {\n        const obj = Object.assign({}, record, { [field]: value })\n        unwinded.push(obj)\n      })\n    })\n    this.data = unwinded\n    return this\n  }\n\n  group (options) {\n    // check and extract group id\n    let id\n    if (typeof options === 'string' || Array.isArray(options)) {\n      id = options\n    } else if (Object.keys(options).indexOf('id') !== -1) {\n      id = options.id\n      delete options.id\n    } else {\n      if (isDevelopmentEnv) {\n        throw Error('group :: an id field is required.')\n      }\n    }\n\n    // there are no group operators defined\n    // simply return group ids\n    if (typeof options === 'string' ||\n      Array.isArray(options) ||\n      Object.keys(options).length === 0) {\n      this.data = this.data.reduce((aggregated, record) => {\n        const groupId = getGroupId(id, record)\n        return getGroupKeys(groupId, aggregated)\n      }, [])\n      return this\n    }\n\n    if (typeof id === 'string' || Array.isArray(id)) {\n      this.data = this.data.reduce((aggregated, record) => {\n        const fields = Object.keys(options)\n        const groupId = getGroupId(id, record)\n\n        // the record does not belong to a group\n        if (typeof groupId === 'undefined') {\n          return aggregated\n        }\n\n        const groupObj = getGroup(groupId, aggregated)\n        for (const field of fields) {\n          groupObj[field] = resolveOperator({\n            operatorObj: options[field],\n            currentValue: groupObj[field],\n            groupId,\n            record\n          })\n        }\n        aggregated.push(groupObj)\n        return aggregated\n      }, [])\n\n      return this\n    }\n  }\n\n  sort (criteria, compareFn = null) {\n    for (const field of Object.keys(criteria)) {\n      const sortValue = criteria[field]\n      if (!Number.isInteger(sortValue) ||\n          Math.abs(sortValue) !== 1) {\n        throw SyntaxError('sort :: criteria need to use either 1 or -1.')\n      }\n    }\n    const fields = Object.keys(criteria)\n    function compare (a, b, i = 0) {\n      const field = fields[i]\n      const order = criteria[field]\n      if (a[field] < b[field]) {\n        return order * (-1)\n      } else if (a[field] > b[field]) {\n        return order * (1)\n      } else {\n        return compare(a, b, i + 1)\n      }\n    }\n    this.data = this.data.sort(compareFn || compare)\n    return this\n  }\n\n  limit (n) {\n    this.data = this.data.slice(0, n)\n    return this\n  }\n\n  exec () {\n    const { data } = this\n    this.data = this.cache\n    return data\n  }\n\n}\n\nmodule.exports = Collection\n","const Collection = require('./lib/Collection')\n\nmodule.exports = { Collection }"]}